// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: veinsgym.proto

#ifndef PROTOBUF_INCLUDED_veinsgym_2eproto
#define PROTOBUF_INCLUDED_veinsgym_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_veinsgym_2eproto 

namespace protobuf_veinsgym_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_veinsgym_2eproto
namespace veinsgym {
namespace proto {
class Box;
class BoxDefaultTypeInternal;
extern BoxDefaultTypeInternal _Box_default_instance_;
class Dict;
class DictDefaultTypeInternal;
extern DictDefaultTypeInternal _Dict_default_instance_;
class Dict_Item;
class Dict_ItemDefaultTypeInternal;
extern Dict_ItemDefaultTypeInternal _Dict_Item_default_instance_;
class Discrete;
class DiscreteDefaultTypeInternal;
extern DiscreteDefaultTypeInternal _Discrete_default_instance_;
class Init;
class InitDefaultTypeInternal;
extern InitDefaultTypeInternal _Init_default_instance_;
class MultiBinary;
class MultiBinaryDefaultTypeInternal;
extern MultiBinaryDefaultTypeInternal _MultiBinary_default_instance_;
class MultiDiscrete;
class MultiDiscreteDefaultTypeInternal;
extern MultiDiscreteDefaultTypeInternal _MultiDiscrete_default_instance_;
class Reply;
class ReplyDefaultTypeInternal;
extern ReplyDefaultTypeInternal _Reply_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Shutdown;
class ShutdownDefaultTypeInternal;
extern ShutdownDefaultTypeInternal _Shutdown_default_instance_;
class Space;
class SpaceDefaultTypeInternal;
extern SpaceDefaultTypeInternal _Space_default_instance_;
class Step;
class StepDefaultTypeInternal;
extern StepDefaultTypeInternal _Step_default_instance_;
class Tuple;
class TupleDefaultTypeInternal;
extern TupleDefaultTypeInternal _Tuple_default_instance_;
}  // namespace proto
}  // namespace veinsgym
namespace google {
namespace protobuf {
template<> ::veinsgym::proto::Box* Arena::CreateMaybeMessage<::veinsgym::proto::Box>(Arena*);
template<> ::veinsgym::proto::Dict* Arena::CreateMaybeMessage<::veinsgym::proto::Dict>(Arena*);
template<> ::veinsgym::proto::Dict_Item* Arena::CreateMaybeMessage<::veinsgym::proto::Dict_Item>(Arena*);
template<> ::veinsgym::proto::Discrete* Arena::CreateMaybeMessage<::veinsgym::proto::Discrete>(Arena*);
template<> ::veinsgym::proto::Init* Arena::CreateMaybeMessage<::veinsgym::proto::Init>(Arena*);
template<> ::veinsgym::proto::MultiBinary* Arena::CreateMaybeMessage<::veinsgym::proto::MultiBinary>(Arena*);
template<> ::veinsgym::proto::MultiDiscrete* Arena::CreateMaybeMessage<::veinsgym::proto::MultiDiscrete>(Arena*);
template<> ::veinsgym::proto::Reply* Arena::CreateMaybeMessage<::veinsgym::proto::Reply>(Arena*);
template<> ::veinsgym::proto::Request* Arena::CreateMaybeMessage<::veinsgym::proto::Request>(Arena*);
template<> ::veinsgym::proto::Shutdown* Arena::CreateMaybeMessage<::veinsgym::proto::Shutdown>(Arena*);
template<> ::veinsgym::proto::Space* Arena::CreateMaybeMessage<::veinsgym::proto::Space>(Arena*);
template<> ::veinsgym::proto::Step* Arena::CreateMaybeMessage<::veinsgym::proto::Step>(Arena*);
template<> ::veinsgym::proto::Tuple* Arena::CreateMaybeMessage<::veinsgym::proto::Tuple>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace veinsgym {
namespace proto {

// ===================================================================

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum PayloadCase {
    kInit = 2,
    kShutdown = 3,
    kStep = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(NULL);
  }

  Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // .veinsgym.proto.Init init = 2;
  bool has_init() const;
  void clear_init();
  static const int kInitFieldNumber = 2;
  private:
  const ::veinsgym::proto::Init& _internal_init() const;
  public:
  const ::veinsgym::proto::Init& init() const;
  ::veinsgym::proto::Init* release_init();
  ::veinsgym::proto::Init* mutable_init();
  void set_allocated_init(::veinsgym::proto::Init* init);

  // .veinsgym.proto.Shutdown shutdown = 3;
  bool has_shutdown() const;
  void clear_shutdown();
  static const int kShutdownFieldNumber = 3;
  private:
  const ::veinsgym::proto::Shutdown& _internal_shutdown() const;
  public:
  const ::veinsgym::proto::Shutdown& shutdown() const;
  ::veinsgym::proto::Shutdown* release_shutdown();
  ::veinsgym::proto::Shutdown* mutable_shutdown();
  void set_allocated_shutdown(::veinsgym::proto::Shutdown* shutdown);

  // .veinsgym.proto.Step step = 4;
  bool has_step() const;
  void clear_step();
  static const int kStepFieldNumber = 4;
  private:
  const ::veinsgym::proto::Step& _internal_step() const;
  public:
  const ::veinsgym::proto::Step& step() const;
  ::veinsgym::proto::Step* release_step();
  ::veinsgym::proto::Step* mutable_step();
  void set_allocated_step(::veinsgym::proto::Step* step);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:veinsgym.proto.Request)
 private:
  void set_has_init();
  void set_has_shutdown();
  void set_has_step();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 id_;
  union PayloadUnion {
    PayloadUnion() {}
    ::veinsgym::proto::Init* init_;
    ::veinsgym::proto::Shutdown* shutdown_;
    ::veinsgym::proto::Step* step_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Reply) */ {
 public:
  Reply();
  virtual ~Reply();

  Reply(const Reply& from);

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reply(Reply&& from) noexcept
    : Reply() {
    *this = ::std::move(from);
  }

  inline Reply& operator=(Reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply& default_instance();

  enum PayloadCase {
    kInit = 2,
    kShutdown = 3,
    kAction = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reply* internal_default_instance() {
    return reinterpret_cast<const Reply*>(
               &_Reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Reply* other);
  friend void swap(Reply& a, Reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reply* New() const final {
    return CreateMaybeMessage<Reply>(NULL);
  }

  Reply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Reply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // .veinsgym.proto.Init init = 2;
  bool has_init() const;
  void clear_init();
  static const int kInitFieldNumber = 2;
  private:
  const ::veinsgym::proto::Init& _internal_init() const;
  public:
  const ::veinsgym::proto::Init& init() const;
  ::veinsgym::proto::Init* release_init();
  ::veinsgym::proto::Init* mutable_init();
  void set_allocated_init(::veinsgym::proto::Init* init);

  // .veinsgym.proto.Shutdown shutdown = 3;
  bool has_shutdown() const;
  void clear_shutdown();
  static const int kShutdownFieldNumber = 3;
  private:
  const ::veinsgym::proto::Shutdown& _internal_shutdown() const;
  public:
  const ::veinsgym::proto::Shutdown& shutdown() const;
  ::veinsgym::proto::Shutdown* release_shutdown();
  ::veinsgym::proto::Shutdown* mutable_shutdown();
  void set_allocated_shutdown(::veinsgym::proto::Shutdown* shutdown);

  // .veinsgym.proto.Space action = 4;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 4;
  private:
  const ::veinsgym::proto::Space& _internal_action() const;
  public:
  const ::veinsgym::proto::Space& action() const;
  ::veinsgym::proto::Space* release_action();
  ::veinsgym::proto::Space* mutable_action();
  void set_allocated_action(::veinsgym::proto::Space* action);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:veinsgym.proto.Reply)
 private:
  void set_has_init();
  void set_has_shutdown();
  void set_has_action();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 id_;
  union PayloadUnion {
    PayloadUnion() {}
    ::veinsgym::proto::Init* init_;
    ::veinsgym::proto::Shutdown* shutdown_;
    ::veinsgym::proto::Space* action_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Init : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Init) */ {
 public:
  Init();
  virtual ~Init();

  Init(const Init& from);

  inline Init& operator=(const Init& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Init(Init&& from) noexcept
    : Init() {
    *this = ::std::move(from);
  }

  inline Init& operator=(Init&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Init& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Init* internal_default_instance() {
    return reinterpret_cast<const Init*>(
               &_Init_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Init* other);
  friend void swap(Init& a, Init& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Init* New() const final {
    return CreateMaybeMessage<Init>(NULL);
  }

  Init* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Init>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Init& from);
  void MergeFrom(const Init& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Init* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string action_space_code = 1;
  void clear_action_space_code();
  static const int kActionSpaceCodeFieldNumber = 1;
  const ::std::string& action_space_code() const;
  void set_action_space_code(const ::std::string& value);
  #if LANG_CXX11
  void set_action_space_code(::std::string&& value);
  #endif
  void set_action_space_code(const char* value);
  void set_action_space_code(const char* value, size_t size);
  ::std::string* mutable_action_space_code();
  ::std::string* release_action_space_code();
  void set_allocated_action_space_code(::std::string* action_space_code);

  // string observation_space_code = 2;
  void clear_observation_space_code();
  static const int kObservationSpaceCodeFieldNumber = 2;
  const ::std::string& observation_space_code() const;
  void set_observation_space_code(const ::std::string& value);
  #if LANG_CXX11
  void set_observation_space_code(::std::string&& value);
  #endif
  void set_observation_space_code(const char* value);
  void set_observation_space_code(const char* value, size_t size);
  ::std::string* mutable_observation_space_code();
  ::std::string* release_observation_space_code();
  void set_allocated_observation_space_code(::std::string* observation_space_code);

  // string reward_space_code = 3;
  void clear_reward_space_code();
  static const int kRewardSpaceCodeFieldNumber = 3;
  const ::std::string& reward_space_code() const;
  void set_reward_space_code(const ::std::string& value);
  #if LANG_CXX11
  void set_reward_space_code(::std::string&& value);
  #endif
  void set_reward_space_code(const char* value);
  void set_reward_space_code(const char* value, size_t size);
  ::std::string* mutable_reward_space_code();
  ::std::string* release_reward_space_code();
  void set_allocated_reward_space_code(::std::string* reward_space_code);

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Init)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr action_space_code_;
  ::google::protobuf::internal::ArenaStringPtr observation_space_code_;
  ::google::protobuf::internal::ArenaStringPtr reward_space_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Shutdown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Shutdown) */ {
 public:
  Shutdown();
  virtual ~Shutdown();

  Shutdown(const Shutdown& from);

  inline Shutdown& operator=(const Shutdown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Shutdown(Shutdown&& from) noexcept
    : Shutdown() {
    *this = ::std::move(from);
  }

  inline Shutdown& operator=(Shutdown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Shutdown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Shutdown* internal_default_instance() {
    return reinterpret_cast<const Shutdown*>(
               &_Shutdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Shutdown* other);
  friend void swap(Shutdown& a, Shutdown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Shutdown* New() const final {
    return CreateMaybeMessage<Shutdown>(NULL);
  }

  Shutdown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Shutdown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Shutdown& from);
  void MergeFrom(const Shutdown& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shutdown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Shutdown)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Step : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Step) */ {
 public:
  Step();
  virtual ~Step();

  Step(const Step& from);

  inline Step& operator=(const Step& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Step(Step&& from) noexcept
    : Step() {
    *this = ::std::move(from);
  }

  inline Step& operator=(Step&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Step& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Step* internal_default_instance() {
    return reinterpret_cast<const Step*>(
               &_Step_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Step* other);
  friend void swap(Step& a, Step& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Step* New() const final {
    return CreateMaybeMessage<Step>(NULL);
  }

  Step* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Step>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Step& from);
  void MergeFrom(const Step& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Step* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .veinsgym.proto.Space observation = 1;
  bool has_observation() const;
  void clear_observation();
  static const int kObservationFieldNumber = 1;
  private:
  const ::veinsgym::proto::Space& _internal_observation() const;
  public:
  const ::veinsgym::proto::Space& observation() const;
  ::veinsgym::proto::Space* release_observation();
  ::veinsgym::proto::Space* mutable_observation();
  void set_allocated_observation(::veinsgym::proto::Space* observation);

  // .veinsgym.proto.Space reward = 2;
  bool has_reward() const;
  void clear_reward();
  static const int kRewardFieldNumber = 2;
  private:
  const ::veinsgym::proto::Space& _internal_reward() const;
  public:
  const ::veinsgym::proto::Space& reward() const;
  ::veinsgym::proto::Space* release_reward();
  ::veinsgym::proto::Space* mutable_reward();
  void set_allocated_reward(::veinsgym::proto::Space* reward);

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Step)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::veinsgym::proto::Space* observation_;
  ::veinsgym::proto::Space* reward_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Space : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Space) */ {
 public:
  Space();
  virtual ~Space();

  Space(const Space& from);

  inline Space& operator=(const Space& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Space(Space&& from) noexcept
    : Space() {
    *this = ::std::move(from);
  }

  inline Space& operator=(Space&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Space& default_instance();

  enum ValueCase {
    kBox = 1,
    kDict = 2,
    kDiscrete = 3,
    kMultiBinary = 4,
    kMultiDiscrete = 5,
    kTuple = 6,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Space* internal_default_instance() {
    return reinterpret_cast<const Space*>(
               &_Space_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Space* other);
  friend void swap(Space& a, Space& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Space* New() const final {
    return CreateMaybeMessage<Space>(NULL);
  }

  Space* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Space>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Space& from);
  void MergeFrom(const Space& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Space* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .veinsgym.proto.Box box = 1;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 1;
  private:
  const ::veinsgym::proto::Box& _internal_box() const;
  public:
  const ::veinsgym::proto::Box& box() const;
  ::veinsgym::proto::Box* release_box();
  ::veinsgym::proto::Box* mutable_box();
  void set_allocated_box(::veinsgym::proto::Box* box);

  // .veinsgym.proto.Dict dict = 2;
  bool has_dict() const;
  void clear_dict();
  static const int kDictFieldNumber = 2;
  private:
  const ::veinsgym::proto::Dict& _internal_dict() const;
  public:
  const ::veinsgym::proto::Dict& dict() const;
  ::veinsgym::proto::Dict* release_dict();
  ::veinsgym::proto::Dict* mutable_dict();
  void set_allocated_dict(::veinsgym::proto::Dict* dict);

  // .veinsgym.proto.Discrete discrete = 3;
  bool has_discrete() const;
  void clear_discrete();
  static const int kDiscreteFieldNumber = 3;
  private:
  const ::veinsgym::proto::Discrete& _internal_discrete() const;
  public:
  const ::veinsgym::proto::Discrete& discrete() const;
  ::veinsgym::proto::Discrete* release_discrete();
  ::veinsgym::proto::Discrete* mutable_discrete();
  void set_allocated_discrete(::veinsgym::proto::Discrete* discrete);

  // .veinsgym.proto.MultiBinary multi_binary = 4;
  bool has_multi_binary() const;
  void clear_multi_binary();
  static const int kMultiBinaryFieldNumber = 4;
  private:
  const ::veinsgym::proto::MultiBinary& _internal_multi_binary() const;
  public:
  const ::veinsgym::proto::MultiBinary& multi_binary() const;
  ::veinsgym::proto::MultiBinary* release_multi_binary();
  ::veinsgym::proto::MultiBinary* mutable_multi_binary();
  void set_allocated_multi_binary(::veinsgym::proto::MultiBinary* multi_binary);

  // .veinsgym.proto.MultiDiscrete multi_discrete = 5;
  bool has_multi_discrete() const;
  void clear_multi_discrete();
  static const int kMultiDiscreteFieldNumber = 5;
  private:
  const ::veinsgym::proto::MultiDiscrete& _internal_multi_discrete() const;
  public:
  const ::veinsgym::proto::MultiDiscrete& multi_discrete() const;
  ::veinsgym::proto::MultiDiscrete* release_multi_discrete();
  ::veinsgym::proto::MultiDiscrete* mutable_multi_discrete();
  void set_allocated_multi_discrete(::veinsgym::proto::MultiDiscrete* multi_discrete);

  // .veinsgym.proto.Tuple tuple = 6;
  bool has_tuple() const;
  void clear_tuple();
  static const int kTupleFieldNumber = 6;
  private:
  const ::veinsgym::proto::Tuple& _internal_tuple() const;
  public:
  const ::veinsgym::proto::Tuple& tuple() const;
  ::veinsgym::proto::Tuple* release_tuple();
  ::veinsgym::proto::Tuple* mutable_tuple();
  void set_allocated_tuple(::veinsgym::proto::Tuple* tuple);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:veinsgym.proto.Space)
 private:
  void set_has_box();
  void set_has_dict();
  void set_has_discrete();
  void set_has_multi_binary();
  void set_has_multi_discrete();
  void set_has_tuple();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::veinsgym::proto::Box* box_;
    ::veinsgym::proto::Dict* dict_;
    ::veinsgym::proto::Discrete* discrete_;
    ::veinsgym::proto::MultiBinary* multi_binary_;
    ::veinsgym::proto::MultiDiscrete* multi_discrete_;
    ::veinsgym::proto::Tuple* tuple_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Box : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Box) */ {
 public:
  Box();
  virtual ~Box();

  Box(const Box& from);

  inline Box& operator=(const Box& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Box(Box&& from) noexcept
    : Box() {
    *this = ::std::move(from);
  }

  inline Box& operator=(Box&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Box& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Box* internal_default_instance() {
    return reinterpret_cast<const Box*>(
               &_Box_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Box* other);
  friend void swap(Box& a, Box& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Box* New() const final {
    return CreateMaybeMessage<Box>(NULL);
  }

  Box* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Box>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Box& from);
  void MergeFrom(const Box& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField< double >&
      values() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Box)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Dict_Item : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Dict.Item) */ {
 public:
  Dict_Item();
  virtual ~Dict_Item();

  Dict_Item(const Dict_Item& from);

  inline Dict_Item& operator=(const Dict_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Dict_Item(Dict_Item&& from) noexcept
    : Dict_Item() {
    *this = ::std::move(from);
  }

  inline Dict_Item& operator=(Dict_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dict_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dict_Item* internal_default_instance() {
    return reinterpret_cast<const Dict_Item*>(
               &_Dict_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Dict_Item* other);
  friend void swap(Dict_Item& a, Dict_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Dict_Item* New() const final {
    return CreateMaybeMessage<Dict_Item>(NULL);
  }

  Dict_Item* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Dict_Item>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Dict_Item& from);
  void MergeFrom(const Dict_Item& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dict_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .veinsgym.proto.Space value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::veinsgym::proto::Space& _internal_value() const;
  public:
  const ::veinsgym::proto::Space& value() const;
  ::veinsgym::proto::Space* release_value();
  ::veinsgym::proto::Space* mutable_value();
  void set_allocated_value(::veinsgym::proto::Space* value);

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Dict.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::veinsgym::proto::Space* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Dict : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Dict) */ {
 public:
  Dict();
  virtual ~Dict();

  Dict(const Dict& from);

  inline Dict& operator=(const Dict& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Dict(Dict&& from) noexcept
    : Dict() {
    *this = ::std::move(from);
  }

  inline Dict& operator=(Dict&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dict& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dict* internal_default_instance() {
    return reinterpret_cast<const Dict*>(
               &_Dict_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Dict* other);
  friend void swap(Dict& a, Dict& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Dict* New() const final {
    return CreateMaybeMessage<Dict>(NULL);
  }

  Dict* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Dict>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Dict& from);
  void MergeFrom(const Dict& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dict* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Dict_Item Item;

  // accessors -------------------------------------------------------

  // repeated .veinsgym.proto.Dict.Item values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::veinsgym::proto::Dict_Item* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::veinsgym::proto::Dict_Item >*
      mutable_values();
  const ::veinsgym::proto::Dict_Item& values(int index) const;
  ::veinsgym::proto::Dict_Item* add_values();
  const ::google::protobuf::RepeatedPtrField< ::veinsgym::proto::Dict_Item >&
      values() const;

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Dict)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::veinsgym::proto::Dict_Item > values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Discrete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Discrete) */ {
 public:
  Discrete();
  virtual ~Discrete();

  Discrete(const Discrete& from);

  inline Discrete& operator=(const Discrete& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Discrete(Discrete&& from) noexcept
    : Discrete() {
    *this = ::std::move(from);
  }

  inline Discrete& operator=(Discrete&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Discrete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Discrete* internal_default_instance() {
    return reinterpret_cast<const Discrete*>(
               &_Discrete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Discrete* other);
  friend void swap(Discrete& a, Discrete& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Discrete* New() const final {
    return CreateMaybeMessage<Discrete>(NULL);
  }

  Discrete* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Discrete>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Discrete& from);
  void MergeFrom(const Discrete& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Discrete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Discrete)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiBinary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.MultiBinary) */ {
 public:
  MultiBinary();
  virtual ~MultiBinary();

  MultiBinary(const MultiBinary& from);

  inline MultiBinary& operator=(const MultiBinary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiBinary(MultiBinary&& from) noexcept
    : MultiBinary() {
    *this = ::std::move(from);
  }

  inline MultiBinary& operator=(MultiBinary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiBinary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiBinary* internal_default_instance() {
    return reinterpret_cast<const MultiBinary*>(
               &_MultiBinary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(MultiBinary* other);
  friend void swap(MultiBinary& a, MultiBinary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiBinary* New() const final {
    return CreateMaybeMessage<MultiBinary>(NULL);
  }

  MultiBinary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiBinary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiBinary& from);
  void MergeFrom(const MultiBinary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiBinary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      values() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:veinsgym.proto.MultiBinary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< bool > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiDiscrete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.MultiDiscrete) */ {
 public:
  MultiDiscrete();
  virtual ~MultiDiscrete();

  MultiDiscrete(const MultiDiscrete& from);

  inline MultiDiscrete& operator=(const MultiDiscrete& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiDiscrete(MultiDiscrete&& from) noexcept
    : MultiDiscrete() {
    *this = ::std::move(from);
  }

  inline MultiDiscrete& operator=(MultiDiscrete&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiDiscrete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiDiscrete* internal_default_instance() {
    return reinterpret_cast<const MultiDiscrete*>(
               &_MultiDiscrete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(MultiDiscrete* other);
  friend void swap(MultiDiscrete& a, MultiDiscrete& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiDiscrete* New() const final {
    return CreateMaybeMessage<MultiDiscrete>(NULL);
  }

  MultiDiscrete* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiDiscrete>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiDiscrete& from);
  void MergeFrom(const MultiDiscrete& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiDiscrete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::uint64 values(int index) const;
  void set_values(int index, ::google::protobuf::uint64 value);
  void add_values(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:veinsgym.proto.MultiDiscrete)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tuple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Tuple) */ {
 public:
  Tuple();
  virtual ~Tuple();

  Tuple(const Tuple& from);

  inline Tuple& operator=(const Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tuple(Tuple&& from) noexcept
    : Tuple() {
    *this = ::std::move(from);
  }

  inline Tuple& operator=(Tuple&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tuple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tuple* internal_default_instance() {
    return reinterpret_cast<const Tuple*>(
               &_Tuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Tuple* other);
  friend void swap(Tuple& a, Tuple& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tuple* New() const final {
    return CreateMaybeMessage<Tuple>(NULL);
  }

  Tuple* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tuple>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tuple& from);
  void MergeFrom(const Tuple& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tuple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .veinsgym.proto.Space values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::veinsgym::proto::Space* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::veinsgym::proto::Space >*
      mutable_values();
  const ::veinsgym::proto::Space& values(int index) const;
  ::veinsgym::proto::Space* add_values();
  const ::google::protobuf::RepeatedPtrField< ::veinsgym::proto::Space >&
      values() const;

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Tuple)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::veinsgym::proto::Space > values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_veinsgym_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// uint64 id = 1;
inline void Request::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Request::id() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Request.id)
  return id_;
}
inline void Request::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:veinsgym.proto.Request.id)
}

// .veinsgym.proto.Init init = 2;
inline bool Request::has_init() const {
  return payload_case() == kInit;
}
inline void Request::set_has_init() {
  _oneof_case_[0] = kInit;
}
inline void Request::clear_init() {
  if (has_init()) {
    delete payload_.init_;
    clear_has_payload();
  }
}
inline const ::veinsgym::proto::Init& Request::_internal_init() const {
  return *payload_.init_;
}
inline ::veinsgym::proto::Init* Request::release_init() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Request.init)
  if (has_init()) {
    clear_has_payload();
      ::veinsgym::proto::Init* temp = payload_.init_;
    payload_.init_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::Init& Request::init() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Request.init)
  return has_init()
      ? *payload_.init_
      : *reinterpret_cast< ::veinsgym::proto::Init*>(&::veinsgym::proto::_Init_default_instance_);
}
inline ::veinsgym::proto::Init* Request::mutable_init() {
  if (!has_init()) {
    clear_payload();
    set_has_init();
    payload_.init_ = CreateMaybeMessage< ::veinsgym::proto::Init >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Request.init)
  return payload_.init_;
}

// .veinsgym.proto.Shutdown shutdown = 3;
inline bool Request::has_shutdown() const {
  return payload_case() == kShutdown;
}
inline void Request::set_has_shutdown() {
  _oneof_case_[0] = kShutdown;
}
inline void Request::clear_shutdown() {
  if (has_shutdown()) {
    delete payload_.shutdown_;
    clear_has_payload();
  }
}
inline const ::veinsgym::proto::Shutdown& Request::_internal_shutdown() const {
  return *payload_.shutdown_;
}
inline ::veinsgym::proto::Shutdown* Request::release_shutdown() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Request.shutdown)
  if (has_shutdown()) {
    clear_has_payload();
      ::veinsgym::proto::Shutdown* temp = payload_.shutdown_;
    payload_.shutdown_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::Shutdown& Request::shutdown() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Request.shutdown)
  return has_shutdown()
      ? *payload_.shutdown_
      : *reinterpret_cast< ::veinsgym::proto::Shutdown*>(&::veinsgym::proto::_Shutdown_default_instance_);
}
inline ::veinsgym::proto::Shutdown* Request::mutable_shutdown() {
  if (!has_shutdown()) {
    clear_payload();
    set_has_shutdown();
    payload_.shutdown_ = CreateMaybeMessage< ::veinsgym::proto::Shutdown >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Request.shutdown)
  return payload_.shutdown_;
}

// .veinsgym.proto.Step step = 4;
inline bool Request::has_step() const {
  return payload_case() == kStep;
}
inline void Request::set_has_step() {
  _oneof_case_[0] = kStep;
}
inline void Request::clear_step() {
  if (has_step()) {
    delete payload_.step_;
    clear_has_payload();
  }
}
inline const ::veinsgym::proto::Step& Request::_internal_step() const {
  return *payload_.step_;
}
inline ::veinsgym::proto::Step* Request::release_step() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Request.step)
  if (has_step()) {
    clear_has_payload();
      ::veinsgym::proto::Step* temp = payload_.step_;
    payload_.step_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::Step& Request::step() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Request.step)
  return has_step()
      ? *payload_.step_
      : *reinterpret_cast< ::veinsgym::proto::Step*>(&::veinsgym::proto::_Step_default_instance_);
}
inline ::veinsgym::proto::Step* Request::mutable_step() {
  if (!has_step()) {
    clear_payload();
    set_has_step();
    payload_.step_ = CreateMaybeMessage< ::veinsgym::proto::Step >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Request.step)
  return payload_.step_;
}

inline bool Request::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Request::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Request::PayloadCase Request::payload_case() const {
  return Request::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Reply

// uint64 id = 1;
inline void Reply::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Reply::id() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Reply.id)
  return id_;
}
inline void Reply::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:veinsgym.proto.Reply.id)
}

// .veinsgym.proto.Init init = 2;
inline bool Reply::has_init() const {
  return payload_case() == kInit;
}
inline void Reply::set_has_init() {
  _oneof_case_[0] = kInit;
}
inline void Reply::clear_init() {
  if (has_init()) {
    delete payload_.init_;
    clear_has_payload();
  }
}
inline const ::veinsgym::proto::Init& Reply::_internal_init() const {
  return *payload_.init_;
}
inline ::veinsgym::proto::Init* Reply::release_init() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Reply.init)
  if (has_init()) {
    clear_has_payload();
      ::veinsgym::proto::Init* temp = payload_.init_;
    payload_.init_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::Init& Reply::init() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Reply.init)
  return has_init()
      ? *payload_.init_
      : *reinterpret_cast< ::veinsgym::proto::Init*>(&::veinsgym::proto::_Init_default_instance_);
}
inline ::veinsgym::proto::Init* Reply::mutable_init() {
  if (!has_init()) {
    clear_payload();
    set_has_init();
    payload_.init_ = CreateMaybeMessage< ::veinsgym::proto::Init >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Reply.init)
  return payload_.init_;
}

// .veinsgym.proto.Shutdown shutdown = 3;
inline bool Reply::has_shutdown() const {
  return payload_case() == kShutdown;
}
inline void Reply::set_has_shutdown() {
  _oneof_case_[0] = kShutdown;
}
inline void Reply::clear_shutdown() {
  if (has_shutdown()) {
    delete payload_.shutdown_;
    clear_has_payload();
  }
}
inline const ::veinsgym::proto::Shutdown& Reply::_internal_shutdown() const {
  return *payload_.shutdown_;
}
inline ::veinsgym::proto::Shutdown* Reply::release_shutdown() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Reply.shutdown)
  if (has_shutdown()) {
    clear_has_payload();
      ::veinsgym::proto::Shutdown* temp = payload_.shutdown_;
    payload_.shutdown_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::Shutdown& Reply::shutdown() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Reply.shutdown)
  return has_shutdown()
      ? *payload_.shutdown_
      : *reinterpret_cast< ::veinsgym::proto::Shutdown*>(&::veinsgym::proto::_Shutdown_default_instance_);
}
inline ::veinsgym::proto::Shutdown* Reply::mutable_shutdown() {
  if (!has_shutdown()) {
    clear_payload();
    set_has_shutdown();
    payload_.shutdown_ = CreateMaybeMessage< ::veinsgym::proto::Shutdown >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Reply.shutdown)
  return payload_.shutdown_;
}

// .veinsgym.proto.Space action = 4;
inline bool Reply::has_action() const {
  return payload_case() == kAction;
}
inline void Reply::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void Reply::clear_action() {
  if (has_action()) {
    delete payload_.action_;
    clear_has_payload();
  }
}
inline const ::veinsgym::proto::Space& Reply::_internal_action() const {
  return *payload_.action_;
}
inline ::veinsgym::proto::Space* Reply::release_action() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Reply.action)
  if (has_action()) {
    clear_has_payload();
      ::veinsgym::proto::Space* temp = payload_.action_;
    payload_.action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::Space& Reply::action() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Reply.action)
  return has_action()
      ? *payload_.action_
      : *reinterpret_cast< ::veinsgym::proto::Space*>(&::veinsgym::proto::_Space_default_instance_);
}
inline ::veinsgym::proto::Space* Reply::mutable_action() {
  if (!has_action()) {
    clear_payload();
    set_has_action();
    payload_.action_ = CreateMaybeMessage< ::veinsgym::proto::Space >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Reply.action)
  return payload_.action_;
}

inline bool Reply::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Reply::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Reply::PayloadCase Reply::payload_case() const {
  return Reply::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Init

// string action_space_code = 1;
inline void Init::clear_action_space_code() {
  action_space_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Init::action_space_code() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Init.action_space_code)
  return action_space_code_.GetNoArena();
}
inline void Init::set_action_space_code(const ::std::string& value) {
  
  action_space_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.Init.action_space_code)
}
#if LANG_CXX11
inline void Init::set_action_space_code(::std::string&& value) {
  
  action_space_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:veinsgym.proto.Init.action_space_code)
}
#endif
inline void Init::set_action_space_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  action_space_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:veinsgym.proto.Init.action_space_code)
}
inline void Init::set_action_space_code(const char* value, size_t size) {
  
  action_space_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:veinsgym.proto.Init.action_space_code)
}
inline ::std::string* Init::mutable_action_space_code() {
  
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Init.action_space_code)
  return action_space_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Init::release_action_space_code() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Init.action_space_code)
  
  return action_space_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Init::set_allocated_action_space_code(::std::string* action_space_code) {
  if (action_space_code != NULL) {
    
  } else {
    
  }
  action_space_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action_space_code);
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Init.action_space_code)
}

// string observation_space_code = 2;
inline void Init::clear_observation_space_code() {
  observation_space_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Init::observation_space_code() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Init.observation_space_code)
  return observation_space_code_.GetNoArena();
}
inline void Init::set_observation_space_code(const ::std::string& value) {
  
  observation_space_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.Init.observation_space_code)
}
#if LANG_CXX11
inline void Init::set_observation_space_code(::std::string&& value) {
  
  observation_space_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:veinsgym.proto.Init.observation_space_code)
}
#endif
inline void Init::set_observation_space_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  observation_space_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:veinsgym.proto.Init.observation_space_code)
}
inline void Init::set_observation_space_code(const char* value, size_t size) {
  
  observation_space_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:veinsgym.proto.Init.observation_space_code)
}
inline ::std::string* Init::mutable_observation_space_code() {
  
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Init.observation_space_code)
  return observation_space_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Init::release_observation_space_code() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Init.observation_space_code)
  
  return observation_space_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Init::set_allocated_observation_space_code(::std::string* observation_space_code) {
  if (observation_space_code != NULL) {
    
  } else {
    
  }
  observation_space_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), observation_space_code);
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Init.observation_space_code)
}

// string reward_space_code = 3;
inline void Init::clear_reward_space_code() {
  reward_space_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Init::reward_space_code() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Init.reward_space_code)
  return reward_space_code_.GetNoArena();
}
inline void Init::set_reward_space_code(const ::std::string& value) {
  
  reward_space_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.Init.reward_space_code)
}
#if LANG_CXX11
inline void Init::set_reward_space_code(::std::string&& value) {
  
  reward_space_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:veinsgym.proto.Init.reward_space_code)
}
#endif
inline void Init::set_reward_space_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  reward_space_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:veinsgym.proto.Init.reward_space_code)
}
inline void Init::set_reward_space_code(const char* value, size_t size) {
  
  reward_space_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:veinsgym.proto.Init.reward_space_code)
}
inline ::std::string* Init::mutable_reward_space_code() {
  
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Init.reward_space_code)
  return reward_space_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Init::release_reward_space_code() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Init.reward_space_code)
  
  return reward_space_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Init::set_allocated_reward_space_code(::std::string* reward_space_code) {
  if (reward_space_code != NULL) {
    
  } else {
    
  }
  reward_space_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reward_space_code);
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Init.reward_space_code)
}

// -------------------------------------------------------------------

// Shutdown

// -------------------------------------------------------------------

// Step

// .veinsgym.proto.Space observation = 1;
inline bool Step::has_observation() const {
  return this != internal_default_instance() && observation_ != NULL;
}
inline void Step::clear_observation() {
  if (GetArenaNoVirtual() == NULL && observation_ != NULL) {
    delete observation_;
  }
  observation_ = NULL;
}
inline const ::veinsgym::proto::Space& Step::_internal_observation() const {
  return *observation_;
}
inline const ::veinsgym::proto::Space& Step::observation() const {
  const ::veinsgym::proto::Space* p = observation_;
  // @@protoc_insertion_point(field_get:veinsgym.proto.Step.observation)
  return p != NULL ? *p : *reinterpret_cast<const ::veinsgym::proto::Space*>(
      &::veinsgym::proto::_Space_default_instance_);
}
inline ::veinsgym::proto::Space* Step::release_observation() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Step.observation)
  
  ::veinsgym::proto::Space* temp = observation_;
  observation_ = NULL;
  return temp;
}
inline ::veinsgym::proto::Space* Step::mutable_observation() {
  
  if (observation_ == NULL) {
    auto* p = CreateMaybeMessage<::veinsgym::proto::Space>(GetArenaNoVirtual());
    observation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Step.observation)
  return observation_;
}
inline void Step::set_allocated_observation(::veinsgym::proto::Space* observation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete observation_;
  }
  if (observation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      observation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, observation, submessage_arena);
    }
    
  } else {
    
  }
  observation_ = observation;
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Step.observation)
}

// .veinsgym.proto.Space reward = 2;
inline bool Step::has_reward() const {
  return this != internal_default_instance() && reward_ != NULL;
}
inline void Step::clear_reward() {
  if (GetArenaNoVirtual() == NULL && reward_ != NULL) {
    delete reward_;
  }
  reward_ = NULL;
}
inline const ::veinsgym::proto::Space& Step::_internal_reward() const {
  return *reward_;
}
inline const ::veinsgym::proto::Space& Step::reward() const {
  const ::veinsgym::proto::Space* p = reward_;
  // @@protoc_insertion_point(field_get:veinsgym.proto.Step.reward)
  return p != NULL ? *p : *reinterpret_cast<const ::veinsgym::proto::Space*>(
      &::veinsgym::proto::_Space_default_instance_);
}
inline ::veinsgym::proto::Space* Step::release_reward() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Step.reward)
  
  ::veinsgym::proto::Space* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline ::veinsgym::proto::Space* Step::mutable_reward() {
  
  if (reward_ == NULL) {
    auto* p = CreateMaybeMessage<::veinsgym::proto::Space>(GetArenaNoVirtual());
    reward_ = p;
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Step.reward)
  return reward_;
}
inline void Step::set_allocated_reward(::veinsgym::proto::Space* reward) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reward_;
  }
  if (reward) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reward = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reward, submessage_arena);
    }
    
  } else {
    
  }
  reward_ = reward;
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Step.reward)
}

// -------------------------------------------------------------------

// Space

// .veinsgym.proto.Box box = 1;
inline bool Space::has_box() const {
  return value_case() == kBox;
}
inline void Space::set_has_box() {
  _oneof_case_[0] = kBox;
}
inline void Space::clear_box() {
  if (has_box()) {
    delete value_.box_;
    clear_has_value();
  }
}
inline const ::veinsgym::proto::Box& Space::_internal_box() const {
  return *value_.box_;
}
inline ::veinsgym::proto::Box* Space::release_box() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.box)
  if (has_box()) {
    clear_has_value();
      ::veinsgym::proto::Box* temp = value_.box_;
    value_.box_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::Box& Space::box() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.box)
  return has_box()
      ? *value_.box_
      : *reinterpret_cast< ::veinsgym::proto::Box*>(&::veinsgym::proto::_Box_default_instance_);
}
inline ::veinsgym::proto::Box* Space::mutable_box() {
  if (!has_box()) {
    clear_value();
    set_has_box();
    value_.box_ = CreateMaybeMessage< ::veinsgym::proto::Box >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.box)
  return value_.box_;
}

// .veinsgym.proto.Dict dict = 2;
inline bool Space::has_dict() const {
  return value_case() == kDict;
}
inline void Space::set_has_dict() {
  _oneof_case_[0] = kDict;
}
inline void Space::clear_dict() {
  if (has_dict()) {
    delete value_.dict_;
    clear_has_value();
  }
}
inline const ::veinsgym::proto::Dict& Space::_internal_dict() const {
  return *value_.dict_;
}
inline ::veinsgym::proto::Dict* Space::release_dict() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.dict)
  if (has_dict()) {
    clear_has_value();
      ::veinsgym::proto::Dict* temp = value_.dict_;
    value_.dict_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::Dict& Space::dict() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.dict)
  return has_dict()
      ? *value_.dict_
      : *reinterpret_cast< ::veinsgym::proto::Dict*>(&::veinsgym::proto::_Dict_default_instance_);
}
inline ::veinsgym::proto::Dict* Space::mutable_dict() {
  if (!has_dict()) {
    clear_value();
    set_has_dict();
    value_.dict_ = CreateMaybeMessage< ::veinsgym::proto::Dict >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.dict)
  return value_.dict_;
}

// .veinsgym.proto.Discrete discrete = 3;
inline bool Space::has_discrete() const {
  return value_case() == kDiscrete;
}
inline void Space::set_has_discrete() {
  _oneof_case_[0] = kDiscrete;
}
inline void Space::clear_discrete() {
  if (has_discrete()) {
    delete value_.discrete_;
    clear_has_value();
  }
}
inline const ::veinsgym::proto::Discrete& Space::_internal_discrete() const {
  return *value_.discrete_;
}
inline ::veinsgym::proto::Discrete* Space::release_discrete() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.discrete)
  if (has_discrete()) {
    clear_has_value();
      ::veinsgym::proto::Discrete* temp = value_.discrete_;
    value_.discrete_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::Discrete& Space::discrete() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.discrete)
  return has_discrete()
      ? *value_.discrete_
      : *reinterpret_cast< ::veinsgym::proto::Discrete*>(&::veinsgym::proto::_Discrete_default_instance_);
}
inline ::veinsgym::proto::Discrete* Space::mutable_discrete() {
  if (!has_discrete()) {
    clear_value();
    set_has_discrete();
    value_.discrete_ = CreateMaybeMessage< ::veinsgym::proto::Discrete >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.discrete)
  return value_.discrete_;
}

// .veinsgym.proto.MultiBinary multi_binary = 4;
inline bool Space::has_multi_binary() const {
  return value_case() == kMultiBinary;
}
inline void Space::set_has_multi_binary() {
  _oneof_case_[0] = kMultiBinary;
}
inline void Space::clear_multi_binary() {
  if (has_multi_binary()) {
    delete value_.multi_binary_;
    clear_has_value();
  }
}
inline const ::veinsgym::proto::MultiBinary& Space::_internal_multi_binary() const {
  return *value_.multi_binary_;
}
inline ::veinsgym::proto::MultiBinary* Space::release_multi_binary() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.multi_binary)
  if (has_multi_binary()) {
    clear_has_value();
      ::veinsgym::proto::MultiBinary* temp = value_.multi_binary_;
    value_.multi_binary_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::MultiBinary& Space::multi_binary() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.multi_binary)
  return has_multi_binary()
      ? *value_.multi_binary_
      : *reinterpret_cast< ::veinsgym::proto::MultiBinary*>(&::veinsgym::proto::_MultiBinary_default_instance_);
}
inline ::veinsgym::proto::MultiBinary* Space::mutable_multi_binary() {
  if (!has_multi_binary()) {
    clear_value();
    set_has_multi_binary();
    value_.multi_binary_ = CreateMaybeMessage< ::veinsgym::proto::MultiBinary >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.multi_binary)
  return value_.multi_binary_;
}

// .veinsgym.proto.MultiDiscrete multi_discrete = 5;
inline bool Space::has_multi_discrete() const {
  return value_case() == kMultiDiscrete;
}
inline void Space::set_has_multi_discrete() {
  _oneof_case_[0] = kMultiDiscrete;
}
inline void Space::clear_multi_discrete() {
  if (has_multi_discrete()) {
    delete value_.multi_discrete_;
    clear_has_value();
  }
}
inline const ::veinsgym::proto::MultiDiscrete& Space::_internal_multi_discrete() const {
  return *value_.multi_discrete_;
}
inline ::veinsgym::proto::MultiDiscrete* Space::release_multi_discrete() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.multi_discrete)
  if (has_multi_discrete()) {
    clear_has_value();
      ::veinsgym::proto::MultiDiscrete* temp = value_.multi_discrete_;
    value_.multi_discrete_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::MultiDiscrete& Space::multi_discrete() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.multi_discrete)
  return has_multi_discrete()
      ? *value_.multi_discrete_
      : *reinterpret_cast< ::veinsgym::proto::MultiDiscrete*>(&::veinsgym::proto::_MultiDiscrete_default_instance_);
}
inline ::veinsgym::proto::MultiDiscrete* Space::mutable_multi_discrete() {
  if (!has_multi_discrete()) {
    clear_value();
    set_has_multi_discrete();
    value_.multi_discrete_ = CreateMaybeMessage< ::veinsgym::proto::MultiDiscrete >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.multi_discrete)
  return value_.multi_discrete_;
}

// .veinsgym.proto.Tuple tuple = 6;
inline bool Space::has_tuple() const {
  return value_case() == kTuple;
}
inline void Space::set_has_tuple() {
  _oneof_case_[0] = kTuple;
}
inline void Space::clear_tuple() {
  if (has_tuple()) {
    delete value_.tuple_;
    clear_has_value();
  }
}
inline const ::veinsgym::proto::Tuple& Space::_internal_tuple() const {
  return *value_.tuple_;
}
inline ::veinsgym::proto::Tuple* Space::release_tuple() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.tuple)
  if (has_tuple()) {
    clear_has_value();
      ::veinsgym::proto::Tuple* temp = value_.tuple_;
    value_.tuple_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::veinsgym::proto::Tuple& Space::tuple() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.tuple)
  return has_tuple()
      ? *value_.tuple_
      : *reinterpret_cast< ::veinsgym::proto::Tuple*>(&::veinsgym::proto::_Tuple_default_instance_);
}
inline ::veinsgym::proto::Tuple* Space::mutable_tuple() {
  if (!has_tuple()) {
    clear_value();
    set_has_tuple();
    value_.tuple_ = CreateMaybeMessage< ::veinsgym::proto::Tuple >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.tuple)
  return value_.tuple_;
}

inline bool Space::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Space::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Space::ValueCase Space::value_case() const {
  return Space::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Box

// repeated double values = 1;
inline int Box::values_size() const {
  return values_.size();
}
inline void Box::clear_values() {
  values_.Clear();
}
inline double Box::values(int index) const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Box.values)
  return values_.Get(index);
}
inline void Box::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.Box.values)
}
inline void Box::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:veinsgym.proto.Box.values)
}
inline const ::google::protobuf::RepeatedField< double >&
Box::values() const {
  // @@protoc_insertion_point(field_list:veinsgym.proto.Box.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
Box::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:veinsgym.proto.Box.values)
  return &values_;
}

// -------------------------------------------------------------------

// Dict_Item

// string key = 1;
inline void Dict_Item::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Dict_Item::key() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Dict.Item.key)
  return key_.GetNoArena();
}
inline void Dict_Item::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.Dict.Item.key)
}
#if LANG_CXX11
inline void Dict_Item::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:veinsgym.proto.Dict.Item.key)
}
#endif
inline void Dict_Item::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:veinsgym.proto.Dict.Item.key)
}
inline void Dict_Item::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:veinsgym.proto.Dict.Item.key)
}
inline ::std::string* Dict_Item::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Dict.Item.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Dict_Item::release_key() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Dict.Item.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Dict_Item::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Dict.Item.key)
}

// .veinsgym.proto.Space value = 2;
inline bool Dict_Item::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void Dict_Item::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::veinsgym::proto::Space& Dict_Item::_internal_value() const {
  return *value_;
}
inline const ::veinsgym::proto::Space& Dict_Item::value() const {
  const ::veinsgym::proto::Space* p = value_;
  // @@protoc_insertion_point(field_get:veinsgym.proto.Dict.Item.value)
  return p != NULL ? *p : *reinterpret_cast<const ::veinsgym::proto::Space*>(
      &::veinsgym::proto::_Space_default_instance_);
}
inline ::veinsgym::proto::Space* Dict_Item::release_value() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Dict.Item.value)
  
  ::veinsgym::proto::Space* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::veinsgym::proto::Space* Dict_Item::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::veinsgym::proto::Space>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Dict.Item.value)
  return value_;
}
inline void Dict_Item::set_allocated_value(::veinsgym::proto::Space* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Dict.Item.value)
}

// -------------------------------------------------------------------

// Dict

// repeated .veinsgym.proto.Dict.Item values = 1;
inline int Dict::values_size() const {
  return values_.size();
}
inline void Dict::clear_values() {
  values_.Clear();
}
inline ::veinsgym::proto::Dict_Item* Dict::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Dict.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::veinsgym::proto::Dict_Item >*
Dict::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:veinsgym.proto.Dict.values)
  return &values_;
}
inline const ::veinsgym::proto::Dict_Item& Dict::values(int index) const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Dict.values)
  return values_.Get(index);
}
inline ::veinsgym::proto::Dict_Item* Dict::add_values() {
  // @@protoc_insertion_point(field_add:veinsgym.proto.Dict.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::veinsgym::proto::Dict_Item >&
Dict::values() const {
  // @@protoc_insertion_point(field_list:veinsgym.proto.Dict.values)
  return values_;
}

// -------------------------------------------------------------------

// Discrete

// uint64 value = 1;
inline void Discrete::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Discrete::value() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Discrete.value)
  return value_;
}
inline void Discrete::set_value(::google::protobuf::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:veinsgym.proto.Discrete.value)
}

// -------------------------------------------------------------------

// MultiBinary

// repeated bool values = 1;
inline int MultiBinary::values_size() const {
  return values_.size();
}
inline void MultiBinary::clear_values() {
  values_.Clear();
}
inline bool MultiBinary::values(int index) const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.MultiBinary.values)
  return values_.Get(index);
}
inline void MultiBinary::set_values(int index, bool value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.MultiBinary.values)
}
inline void MultiBinary::add_values(bool value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:veinsgym.proto.MultiBinary.values)
}
inline const ::google::protobuf::RepeatedField< bool >&
MultiBinary::values() const {
  // @@protoc_insertion_point(field_list:veinsgym.proto.MultiBinary.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< bool >*
MultiBinary::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:veinsgym.proto.MultiBinary.values)
  return &values_;
}

// -------------------------------------------------------------------

// MultiDiscrete

// repeated uint64 values = 1;
inline int MultiDiscrete::values_size() const {
  return values_.size();
}
inline void MultiDiscrete::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint64 MultiDiscrete::values(int index) const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.MultiDiscrete.values)
  return values_.Get(index);
}
inline void MultiDiscrete::set_values(int index, ::google::protobuf::uint64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.MultiDiscrete.values)
}
inline void MultiDiscrete::add_values(::google::protobuf::uint64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:veinsgym.proto.MultiDiscrete.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
MultiDiscrete::values() const {
  // @@protoc_insertion_point(field_list:veinsgym.proto.MultiDiscrete.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
MultiDiscrete::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:veinsgym.proto.MultiDiscrete.values)
  return &values_;
}

// -------------------------------------------------------------------

// Tuple

// repeated .veinsgym.proto.Space values = 1;
inline int Tuple::values_size() const {
  return values_.size();
}
inline void Tuple::clear_values() {
  values_.Clear();
}
inline ::veinsgym::proto::Space* Tuple::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Tuple.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::veinsgym::proto::Space >*
Tuple::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:veinsgym.proto.Tuple.values)
  return &values_;
}
inline const ::veinsgym::proto::Space& Tuple::values(int index) const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Tuple.values)
  return values_.Get(index);
}
inline ::veinsgym::proto::Space* Tuple::add_values() {
  // @@protoc_insertion_point(field_add:veinsgym.proto.Tuple.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::veinsgym::proto::Space >&
Tuple::values() const {
  // @@protoc_insertion_point(field_list:veinsgym.proto.Tuple.values)
  return values_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace veinsgym

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_veinsgym_2eproto
